<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>03_spread</title>
</head>

<body>
    <h1>03_spread</h1>
    <script>
        let arr1 = [11, 22, 33, 44, 55] // 1차 배열인 상태(arr1)
        let arr2 = { "고등어구이": 7000, "삼치구이": 8000, "전어구이": 7000 } // 객체 리터럴인 상태=key배열 (arr2)

        // ... : spread 연산자
        // 배열 원소를 개별로 나열 혹은 개별로 나열된 요소들을 배열로 묶음(배열되어 있는 원소를 개별로 나열, 나열된 요소들을 배열로 묶음)

        console.log(arr1) // 배열로 나열
        console.log(...arr1) // 배열 원소를 개별로 나열(...으로 인해 발생)

        console.log(arr2) // key배열로 나열
        // console.log(...arr2) key배열은 spread 연산자 불가('...'은 key배열일 때 불가)

        // ----------------------------------------------------------------------(1) spread에 대한 설명, 배열에는 사용가능, key배열에는 사용 불가 (개별로 나열 및 나열된 개별의 요소를 배열로 묶음)

        function fn_1(a, b, c) {
            console.log("fn_1 실행 :", a, b, c) // 일반 함수를 정의
        }

        // ----------------------------------------------------------------------(2) fn_1이라는 함수명에 매개변수 a,b,c가 있고 {} 안에 console.log(출력)
        // fn_1("아빠상어", "엄마상어", "아기상어",)를 호출했기 때문에 a는 아빠상어, b는 엄마상어, c는 아기상어로 출력됨


        function fn_2(arr) { // arr이 배열
            console.log("fn_2 시작 ----")
            for (const i in arr) {
                console.log("\t", i, arr[i])
            }
            console.log("fn_2 끝 ----")
        }
        // ----------------------------------------------------------------------(3) fn_2이라는 함수명에 매개변수 arr이 있고 {} 안에 console.log(시작과 끝) 그 안에 for문에서 arr의 인덱스 갯수가 i에 할당받음
        // 그리고 console로 출력하는데 i, arr[i]를 할당받음 '0 현빈' 이렇게 출력이 됨 
        // fn_2(["현빈", "원빈", "미스터빈"]) // 호출에서 배열로 만들었기 때문에 arr은 배열형태가 됨. 

        function fn_3(...arr) { // 매개변수를 묶어 배열 처리
            console.log("fn_3 시작 ----")
            for (const i in arr) {
                console.log("\t", i, arr[i])
            }
            console.log("fn_3 끝 ----")
        }

        // ----------------------------------------------------------------------(4) fn_3이라는 함수명에 매개변수를 spread로 ...arr을 만든뒤(비유를 하자면 비빔밥에 있는 재료를 나열하기 보다 그냥 비빔밥 채소라고 
        // 하는게 맘 편하고 쉬우니까 그렇듯 비빔밥 재료를 매개변수에 일일이 넣는 것 보다 비빔밥 채소(spread)를 사용해 쓰는게 편함.)
        // spread는 배열로 묶어주는 역할을 함.
        // fn_3(12, 34, 56, 78) // arr = [12,34,56,78] 결국 []의 차이로 인해 1차원 배열이냐 2차원 배열이 되냐 차이가 난다는 것임.

        function fn_4(a, b, ...arr) { // 매개변수를 묶어 배열 처리 (a, b, ...arr)
            console.log("fn_4 시작 :", a, b)
            for (const i in arr) {
                console.log("\t", i, arr[i])
            }
            console.log("fn_4 끝 ----")
        }

        // ----------------------------------------------------------------------(5) fn_4이라는 함수명에 매개변수를 a, b 그리고 spread ...arr을 만듦(비유를 하자면 비빔밥 재료에서도 핵심적인 것이 있음
        // 그것은 묶어서 보지 않고 전통성을 살리겠다는 얘기임.) 
        //  fn_4(12, 34, 56, 78)로 호출받았으면 a는 12, b는 34, 그리고 나머지 56, 78은 ...arr임. 


        /* spread 매개 변수는 마지막에 배치해야 함 (잘못된 구조)

        function fn_5(...arr,a,b){ // 매개변수를 묶어 배열 처리 (a, b, ...arr)
             console.log("fn_5 시작 :", a, b)
             for (const i in arr) {
                   console.log("\t", i, arr[i])
             }
             console.log("fn_5 끝 ----")
        }
        */
        // ----------------------------------------------------------------------(6) fn_5이라는 함수명에 매개변수를 a, b 그리고 spread ...arr을 만듦(허나 ...arr과 a, b의 순서가 바뀌었음.)
        // 비빔밥 재료에서 나머지들(...arr)은 맨 마지막에 배치해야함. 


        function fn_6(a, b = 2000, ...arr) { // 매개변수를 묶어 배열 처리 (a, b, ...arr)
            console.log("fn_6 시작 :", a, b)
            for (const i in arr) {
                console.log("\t", i, arr[i])
            }
            console.log("fn_6 끝 ----")
        }

        // ----------------------------------------------------------------------(7) fn_6이라는 함수명에 매개변수를 a, b=2000 그리고 spread ...arr을 만듦(b에 2000이라는 값을 줘버림.)
        /* 아래는 호출받은 값들이다. 
        fn_6(12, 34, 56, 78) : 우선 1번째 12,34,56,78에서 a는 12, b는 34 ...arr은 56, 78이 된다.
        fn_6(12, 34) : 2번째 12,34에서 a는 12, b는 34 ...arr은 없다(undefined).
        fn_6(12) : 3번째 12에서 a는 12, b는 없고 ...arr도 없다.(undefined) 원래는 b에 (undefined)가 되어야 하지만 매개변수 b에 2000 값이 있기 때문에 b는 2000으로 출력된다.
        fn_6() : 4번째에 a는 (undefined), b는 2000 ...arr은 (undefined)이 된다.
        */

        /*
        spread 매개변수는 무조건 마지막에 위치
        function fn_7(a,...arr,b = 2000){
             console.log("fn_7 시작 :", a, b)
             for (const i in arr) {
                   console.log("\t", i, arr[i])
             }
             console.log("fn_7 끝 ----")
        }
        */

        // ----------------------------------------------------------------------(8) fn_7이라는 함수명에 매개변수를 a, 중간에 spread ...arr, 마지막에 b=2000으로 설정
        // 아까도 말했듯 비빔밥 재료에서 나머지들(...arr)은 맨 마지막에 배치해야함.  

        /*
        spread 매개변수 다중 처리 불가
        function fn_8(...arr1, ...arr2){ // 
        }
        */

        // ----------------------------------------------------------------------(9) fn_8이라는 함수명에 매개변수를 ...arr1, ...arr2 로 spread를 다중으로 놓았음.
        // 그러면 에러가 뜸. 그러니까 다중 처리하지 말자. 제발. 


        fn_1("아빠상어", "엄마상어", "아기상어",) // 함수 호출

        fn_2(["현빈", "원빈", "미스터빈"]) // 배열로 만듦. fn_2([현빈, ....]) = fn_2(arr) 즉 arr이 배열
        fn_2(12, 34, 56, 78) // 배열이 아니기 때문에 나열불가

        fn_3(12, 34, 56, 78) // arr = [12,34,56,78] 결국 []의 차이로 인해 1차원 배열이냐 2차원 배열이 되냐 차이가 난다는 것임.
        //                          0  1  2  3
        fn_3([12, 34, 56, 78]) // arr = [[12,34,56,78]]
        //                            ---------------
        //                              arr[0]

        fn_3(12, 34)
        fn_3(12)
        fn_3()

        fn_4(12, 34, 56, 78) // a = 12, b = 34, 그리고 arr이 [56, 78]로 배열이 됨.

        fn_6(12, 34, 56, 78)
        fn_6(12, 34)
        fn_6(12)
        fn_6()


        function even(...arr) { // even이라는 함수명에 ...arr이라는 매개변수를 주었음.
            let tot = 0         // 변수 tot를 0을 설정
            for (const ee of arr) { // even(23, 46, 71, 12, 89, 32)을 ...arr이라는 매개변수에 할당. arr의 원소값을 ee에 할당.
                if (ee % 2 == 0) { // 만약에 ee가 2로 나눈 나머지가 0이면(짝수)
                    tot += ee // tot = tot + ee(46,12,32)를 tot = 0 + 46; => tot = 46 + 12; => tot = 58 + 32; => tot = 90;  
                }
            }
            console.log(tot) // tot값을 console.log로 출력
        }

        even(23, 46, 71, 12, 89, 32) // even() 호출

        // ----------------------------------------------------------------------(10)

        function opTion(aa, ...arr2) { // opTion이라는 함수명에 aa(초기설정값), ...arr(비교해야할 값들)이라는 매개변수를 주었음.
            let tot = 0 // 변수 tot를 0을 설정(합계를 위함)
            let ton = 0 // 변수 ton를 0을 설정(개수를 위함)
            for (const ee of arr2) { // aa에 3을 opTion(9, 7, 27, 8, 4, 5, 12, 15, 18, 20)을 ...arr2에 할당받은 원소값을 ee에 할당
                if (ee % aa == 0) { // ee(9, 7, 27, 8, 4, 5, 12, 15, 18, 20)를 aa(3)에 나눈 나머지가 0일 경우(aa의 배수) 
                    tot += ee // tot = tot + ee(9,27,12,15,18)를 tot = 81;
                    ton++ // 3의 배수가 나올 때마다 갯수가 +1
                }
            }
            if (ton) { // ton이 있다면 
            document.write(`${aa}의 배수들의 총점은 '${tot}점'이고 평균은 '${tot / ton}점'입니다.`)} // 출력

            else{ // 그렇지 않다면(ton이 없다면)
                document.write(`${aa}의 배수가 없습니다.<br>`) // 출력
            }
        }

        opTion(3, 9, 7, 27, 8, 4, 5, 12, 15, 18, 20) // 호출값

    </script>
</body>

</html>