<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>06_funcDef</title>
</head>

<body>
    <h1>06_funcDef</h1> <!--function definition 함수 정의-->
    <script>

        // 01. 선언적 형태의 정의

        function fn_1(aa, bb){ // (1) function 이라는 함수를 선언했고, fn_1이라는 함수명을, 매개변수를 aa, bb로 설정
            document.write(`fn_1()실행 : ${aa}, ${bb} <br>`) // (2) 명령어는 ${aa}, ${bb}를 출력하라
            return 1234 // (3) return 값은 1234
        }

        fn_1("티라노", "브라키오") // (4) aa에 티라노, bb에 브라키오를 넣어서 fn_1 함수를 호출하겠다.(리턴값이 아닌 명령어가 실행되어 aa에 티라노, bb에 브라키오가 출력)

        // ------------------------------------------------------------------------------------------------------------------------------------ (1) 기본 대입 방법

        let rr = fn_1("두치", "뿌꾸") // (1) aa에 두치, bb에 뿌꾸를 넣어서 fn_1 함수를 호출하는데 rr이라는 변수에 담을거야.
        document.write(`rr : ${rr} <br>`) // (2) 그러면 rr의 값은 return값 1234를 출력할거야.

        let ff1 = fn_1 // (1) fn_1이라는 함수를 ff1이라는 변수에 담을거야.
        document.write(`ff1 : ${ff1} <br>`) // (2) 함수 자체를 담았기 때문에 출력하면 fn_1의 정의를 모두 출력

        /*(3) function fn_1(aa, bb){
            document.write(`fn_1()실행 : ${aa}, ${bb} <br>`)
            return 1234 / 이거 전체가 출력이 된다.
        }*/

        document.write(`fn_1 : ${fn_1} <br>`) // (1) 마찬가지로 함수 정의내용 출력

        /*(2) function fn_1(aa, bb){
            document.write(`fn_1()실행 : ${aa}, ${bb} <br>`)
            return 1234 / 이거 전체가 출력이 된다.
        }*/

        rr = ff1("장수풍뎅이", "사슴벌레") // (1) ff1(변수) = fn_1(함수) 인 상황에서 rr이라는 변수에 ff1을 담겠다. ff1은 fn_1(함수)이고 호출하겠다고 했으니 aa, bb에 각각 장수풍뎅이, 사슴벌레를
                                        // 대입
        document.write(`rr : ${rr} <br>`) // (2) rr의 값은 ff1(=fn_1)의 값이니까 fn_1의 return값인 1234가 출력

        /*
        function(aa,bb){ (1) 함수명이 없는 상황에 호출을 받을 수 없다. 
            document.write(`익명() 실행 : ${aa}, ${bb} <br>`)
            return 5678
        } (2) 호출도 안했음.
            */

        // ------------------------------------------------------------------------------------------------------------------------------------ (2) 선언적 형태의 정의

        // 02. 함수표현식으로 정의
        // : 선언적 형태의 정의에서는 변수 = 함수명(호출값)으로 해당 함수를 호출했다면, 이번에는 변수 = 함수로 해서 변수를 함수로 사용하는 것임.

        let ff2 = function (aa, bb) { // (1) let ff2라는 변수명에 함수 자체를 담았다. 함수명이 없는 것이 보일 것이다. 매개변수는 aa, bb
            document.write(`익명() 실행 : ${aa}, ${bb} <br>`) // (2) ${aa}, ${bb}를 출력해 
            return 5678 // (3) return 값은 5678
        }

        rr = ff2("톰", "제리") // (4) ff2라는 변수를 rr 변수에 담겠다.(다만 ff2 <= 함수로 담았기 때문에 rr에는 해당 함수가 들어간다는 뜻임 톰, 제리를 각각 aa, bb에 넣겠다)
        document.write(`rr : ${rr} <br>`) // reutrn값인 5678이 출력

        // ------------------------------------------------------------------------------------------------------------------------------------ (3) 함수 표현식의 정의
        // 함수 표현식의 정의에서 화살표 정의를 사용하여 점점 줄여나가겠다는 뜻을 담고 있음.

        // 03. 화살표 함수 형식으로 정의    

        //(매개변수1, 매개변수2....) => {}
        let ff3 = (aa, bb) => { // (1) let 변수명 ff3에 함수 자체를 담는데 function이라는 함수 선언하는 대표단어가 사라짐
            document.write(`화살표함수() 실행 : ${aa}, ${bb} <br>`) // (2) 명령어 ${aa} ${bb}를 출력
            return 9012 // (3) return 값은 9012
        } // ----> 이 코드가 의미하는 것은 function이 사라져도 작동한다는 것임. 대신 '=>'를 사용하여 줄일 수 있게 됨.


        rr = ff3("서수남", "하청일") // (4) ff3라는 변수를 rr 변수에 담겠다.(다만 ff3 <= 함수로 담았기 때문에 rr에는 해당 함수가 들어간다는 뜻임 서수남, 하청일을 각각 aa, bb에 넣겠다)
        document.write(`rr : ${rr} <br>`) // (5) ff3의 리턴값인 9012가 출력

        // ------------------------------------------------------------------------------------------------------------------------------------ (4) 화살표 함수 형식의 정의

        // 04. 익명 함수(함수 재접근 불가하며 일회용)

        rr = (function (aa, bb) { // (1) 변수명 rr에 함수 자체를 담고 함수명은 없는 상태로 매개변수 aa, bb를 넣음
            document.write(`익명 직접실행() : ${aa}, ${bb} <br>`) // (2) 명령어 ${aa} ${bb}를 출력
            return 123 // (3) return 값은 123, 근데 리턴값이 끝나면 {}에서 마무리가 되어야하는데 중괄호 밖에 ()가 있음.
        })("키라", "아스란") // (4) 여기에 ()을 덧붙인 후 해당 키라, 아스란으로 aa, bb에 입력되도록 함.
        document.write(`rr : ${rr} <br>`) // (5) rr의  값은 123이 됨.

        rr = ((aa, bb) => { // (1) 변수명 rr에 함수 자체를 담고 함수명과 function이 없는 상태로 매개변수 aa, bb를 넣음 그리고 =>를 만들어줌
            document.write(`화살표함수 익명 직접 실행() : ${aa}, ${bb} <br>`) // (2) 명령어 ${aa} ${bb}를 출력 / 화살표 함수로 일회용의 익명 함수를 만들었음.
            return 456 // (3) return 값은 456
        })("이치고", "루키아") // 일회용임 / (4) 여기에 ()을 덧붙인 후 해당 이치고, 루키아로 aa, bb에 입력되도록 함.
        document.write(`rr : ${rr} <br>`) // (5) rr의 리턴값인 456 출력
        // 여기에서는 function을 없애고 =>를 넣어서 차이점을 두었음.

        rr = (() => { // (1) 변수명 rr에 함수 자체를 담고 함수명, function, 매개변수가 모두 없는 상태에서 => {}를 넣음
            document.write(` 익명 매개없음1 () <br/>`) // (2) 해당 내용 출력
            return 456 // (3) return 값은 456
        })()

        document.write(`rr : ${rr}<br/>`) // (4) rr의 리턴값인 456 출력
        // 여기에서는 기존에 function, 함수명, 매개변수를 모두 없애고 return만 있는 상태에서도 원활히 작동한다는 것을 보여줌.


        rr = (() => { // (1) 매개변수가 없는 상황에서 실행구문이 return 1개라 {}가 필요없는 상황이지만 {} 넣었음.
            return 789 // (2) return 값은 789
        })() // (3) 호출을 위한 ()을 만들었지만 매개변수가 없기 때문에 쓰이지 못함.

        document.write(`rr : ${rr}<br/>`) // (4) return 값인 789가 출력

        //실행구문이 1개인 경우 {} 생략
        rr = (() => 111)() // (1) 매개변수가 없는 상황에서 실행구문이 return 1개라 {}가 생략되었음.
        // 여기에서는 {}를 생략해도 된다는 것을 보여줌

        document.write(`rr : ${rr}<br/>`) // (2) return 값인 111을 출력

        rr = (() => document.write(` 익명 매개없음2 () <br/>`))() // (1) rr이라는 변수에 매개변수는 없고 => 에 {} 없이 바로 명령어를 넣었음. 
        //(2) return은 주지 않았음. 그리고 호출을 위한 ()을 만들었으나 매개변수가 없기 때문에 사용이 안됨.
        document.write(`rr : ${rr}<br/>`) //(3) rr의 return값은 undefined 로 출력

        /* 매개변수가 없을 경우 () 를 생략할 수 없다
        rr = (document.write(` 익명 매개없음2 () <br/>`) )( )
        document.write(`rr : ${rr}<br/>`) */

        // 매개변수가 1개인 경우 () 매개변수를 담을 그릇 생략 가능
        rr = (aa => document.write(` 익명 ${aa} <br/>`))('탄지로') // 매개변수가 있기 때문에 매개변수를 감싸는 ()를 없애도 되었다.
        document.write(`rr : ${rr}<br/>`)

         // ------------------------------------------------------------------------------------------------------------------------------------ (5) 익명 함수 형식의 정의

        function big1(aa,bb,cc){ // (1)function에 big1이라는 함수명과 aa, bb, cc라는 매개변수를 넣고 {} 안에 
            let res = bb*aa + cc/aa // (2) res라는 변수에 bb * aa + cc / aa를 담았음
            document.write(`big1 : ${res}<br/>`) // (4) res 값은 10*3 + 15/3 = 30 + 5 = 35의 값이 출력
        }

        big1(3,10,15) // (3) big1에 aa =3, bb = 10, cc=15로 호출했음.

        function big2(bb,cc){ // (1) function에 big2이라는 함수명과 bb, cc라는 매개변수를 넣고 {} 안에 / (6) bb = 10, cc = 15를 넣음
            function small(x, y){ // (2) 내부 함수 small이라는 함수명에 x, y라는 매개변수를 넣어서 / (8) small(x=cc, y=bb)이 됨
                return x-y // (3) 내부 함수 small의 return은 x - y임. / (9) return 값은 15-10 = 5가 됨
            }
            let res = small(cc, bb) // (4) res 값은 small에 cc, bb를 x, y에 호출한 것임. / (7) res = small(15, 10)으로 할당됨.
            document.write(`big2 : ${res}<br/>`) // (10) res의 값은 5
        }

        big2(10, 15) // (5) big2에 bb = 10, cc = 15를 호출함

        function big3(bb,cc){ // (1) function에 big3이라는 함수명과 bb, cc라는 매개변수를 넣고 {} 안에 / (6) bb = 10, cc = 15를 넣음
            function small(x, y){ // (2) 내부 함수 small이라는 함수명에 x, y라는 매개변수를 넣어서 / (8) small(x=cc, y=bb)이 됨
                return x+y // (3) 내부 함수 small의 return은 x + y임. / (9) return 값은 15+10 = 25가 됨
            }
            let res = small(cc, bb) // (4) res 값은 small에 cc, bb를 x, y에 호출한 것임 /  (7) res = small(15, 10)으로 할당됨.
            document.write(`big3 : ${res}<br/>`) // (10) res의 값은 25
        }

        big3(10, 15) // (5) big3에 bb = 10, cc = 15를 호출함

        // ------------------------------------------------------------------------------------------------------------------------------------ (6) 고차 함수 형식의 정의
        // 고차 함수 - 함수를 매개변수로 받아 사용하는 함수

        function big4(small, bb,cc){ // (1) function에 big4이라는 함수명을 넣고 매개변수에 small, bb, cc라는 매개변수를 넣고 / (7) small = qqq, bb = 10, cc = 15가 됨
            let res = small(cc, bb) + 1000 // (2) res라는 변수에 small(cc, bb) + 100을 넣음. 어? small은 big4의 매개변수인데 여기서 쓰인다고? / (8) small(cc, bb)는 qqq(x, y)가 되고 small(15,10)이 qqq(x, y)가 된다. / (12) 0.66666+1000 = 1000.6666이 된다.
            document.write(`big4 : ${res}<br/>`) // (13) res = 1000.666666 출력
        }

        function qqq(x, y){ // (3) function에 qqq이라는 함수명을 넣고 매개변수에 x, y라는 매개변수를 넣고 / (9) qqq(x, y)는 small(15, 10)이기에 
            document.write(`qqq 실행 : ${x}, ${y} <br/>`) // (4) ${x}, ${y}를 출력 / (10) x = 15, y = 10이 출력된다.
                return y/x // (5) return 값은 y / x / (11) 10 / 15 = 0.6666  값이 나오고 그게 small(cc, bb)로 입력되어
            }

        big4(qqq, 10, 15) // (6) big4에 small = qqq, bb = 10, cc = 15를 호출함.

    
        /*function big4(small, bb,cc){ // (1) function에 big4이라는 함수명을 넣고 매개변수에 small, bb, cc라는 매개변수를 넣고 / (7) small = ggg함수, bb = 10, cc = 15가 됨
            let res = small(cc, bb) + 1000 // (2) res라는 변수에 small(cc, bb) + 100을 넣음. 어? small은 big4의 매개변수인데 여기서 쓰인다고? / (8) small(cc, bb)는 ggg(x, y)가 되고 small(15,10)이 ggg(x, y)가 된다. / (12) 10+1000 = 1010
            document.write(`big4 : ${res}<br/>`) // (13) res = 1010 출력
        }*/

        big4(function ggg(x, y){ // (1) 호출하는 것 안에 (함수, 값, 값) 형태로 되어 있음. 함수는 ggg라는 함수명에 x, y라는 매개변수가 있고 / (9) ggg(x, y)는 small(15, 10)이기에 
            document.write(`ggg 실행 : ${x}, ${y} <br/>`) // x, y를 출력하라고 함 / (10) 15, 10이 출력
                return y%x // return 값은 y % x / (11) return 값은 10 % 15 = 10
            }, 10, 15) // 여기는 호출할 값들

        // 아까는 함수, 함수, 함수호출 형식이었다면, 방금은 함수, 함수호출이 다임. 함수호출할 때 그 변수를 함수로 둬서 더욱 편리하게 쓴 것임.


        big4(function (x, y){ // (1) 호출하는 것 안에 (함수, 값, 값) 형태로 되어 있는 것은 똑같지만 함수명이 없음. 근데 함수 호출로 사용할 건데 굳이 함수명을 쓰지 않아도 됨.
            document.write(`함수표현식 실행 : ${x}, ${y} <br/>`)
                return x - y + 50
            }, 10, 15)  

        
        big4((x, y) => x/y + 20, 10, 15) // 화살표 형식으로 하면 더 유연하게 사용 가능. 요즘 유행임. 잘 알고 있어야하는 사항.
            

        /*
        대학별 시험점수를 다르게 출력하는 함수를 구현하세요

        입력정보 :이름, 국어 , 영어, 수학
        합격점수 : 70점

        a대학 : 국어 50%, 영어:30%, 수학:20%
        b대학 : 국어 10%, 영어:20%, 수학:70%
        c대학 : 국어 33%, 영어:33%, 수학:34%

        시험 함수는 1개이며 각대학의 점수계산을 고차함수로 처리하세요
        */
        


        /*
        1. 기획 
        2. 생각 -
        ㄴ 
        3. 설계
        4. 구현
        */

        function univ(uni, kor, eng, mat, name){
            let res = uni(kor, eng, mat)
            if(res >= 70){
                document.write(`${name}님 ${res}점으로 합격입니다`)
            }
            else{
                document.write(`${name}님 ${res}점으로 불합격입니다 <br>`)
            }


        }

        univ((aa, bb, cc)=> aa*0.5 + bb*0.3 + cc*0.2, 90, 80, 46, "이영구")
        univ((aa, bb, cc)=> aa*0.1 + bb*0.2 + cc*0.7, 90, 80, 46, "이영팔")
        univ((aa, bb, cc)=> aa*0.33 + bb*0.33 + cc*0.34, 90, 80, 46, "이영칠")



        
         function exam(univ, st){
            let res = '불합격'
            let avg = univ(st.jum)
            if(70<= avg){
                res = "합격"
            }
            document.write(`${st.name}님 ${res}(${avg})입니다.<br/>`)
        }

        exam(arr=> arr[0]*0.5+arr[1]*0.3+arr[2]*0.2, {name:'정우성',jum:[96,68,32]} )
        exam(arr=> {
            let res = 0
            let rate =[0.1,0.2,0.7]
            for (const i in rate) {
                res += arr[i]*rate[i]
            }
            return res
        }, {name:'정우성',jum:[96,68,32]} )
        exam(arr=> arr[0]*0.33+arr[1]*0.33+arr[2]*0.34, {name:'정우성',jum:[96,68,32]} )
        
        
        


        


    </script> 
</body>

</html>